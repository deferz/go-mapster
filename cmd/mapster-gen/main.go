package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"text/template"
)

// MappingPair represents a source-target mapping pair
type MappingPair struct {
	SourceType string
	TargetType string
	Package    string
}

// CodeGenerator generates optimized mapping functions
type CodeGenerator struct {
	mappings []MappingPair
	output   string
}

func main() {
	var (
		pkg    = flag.String("pkg", ".", "Package to analyze")
		output = flag.String("output", "mapster_generated.go", "Output file")
	)
	flag.Parse()

	gen := &CodeGenerator{
		output: *output,
	}

	if err := gen.analyzeMappings(*pkg); err != nil {
		log.Fatal(err)
	}

	if err := gen.generateCode(); err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated optimized mappers in %s\n", *output)
}

func (g *CodeGenerator) analyzeMappings(pkgPath string) error {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, pkgPath, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				// Look for mapster.Map[TargetType](source) calls
				if call, ok := n.(*ast.CallExpr); ok {
					if sel, ok := call.Fun.(*ast.IndexExpr); ok {
						if ident, ok := sel.X.(*ast.SelectorExpr); ok {
							if pkg, ok := ident.X.(*ast.Ident); ok && pkg.Name == "mapster" {
								if ident.Sel.Name == "Map" {
									// Extract target type and source type
									targetType := g.extractType(sel.Index)
									if len(call.Args) > 0 {
										sourceType := g.extractType(call.Args[0])
										g.mappings = append(g.mappings, MappingPair{
											SourceType: sourceType,
											TargetType: targetType,
											Package:    pkg.Name,
										})
									}
								}
							}
						}
					}
				}
				return true
			})
		}
	}

	return nil
}

func (g *CodeGenerator) extractType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", g.extractType(t.X), t.Sel.Name)
	default:
		return "interface{}"
	}
}

func (g *CodeGenerator) generateCode() error {
	tmpl := `// Code generated by mapster-gen. DO NOT EDIT.

package {{ .Package }}

import (
	"reflect"
	"github.com/deferz/go-mapster"
)

func init() {
	// Register generated mappers
{{- range .Mappings }}
	mapster.RegisterGeneratedMapper(
		reflect.TypeOf((*{{ .SourceType }})(nil)).Elem(),
		reflect.TypeOf((*{{ .TargetType }})(nil)).Elem(),
		map{{ .SourceType }}To{{ .TargetType }},
	)
{{- end }}
}

{{- range .Mappings }}

// map{{ .SourceType }}To{{ .TargetType }} is a zero-reflection generated mapper
func map{{ .SourceType }}To{{ .TargetType }}(src interface{}) interface{} {
	s := src.({{ .SourceType }})
	return {{ .TargetType }}{
		// TODO: Generate field mappings based on struct analysis
		// This would be populated by analyzing struct fields
	}
}
{{- end }}
`

	t, err := template.New("mapster").Parse(tmpl)
	if err != nil {
		return err
	}

	file, err := os.Create(g.output)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		Package  string
		Mappings []MappingPair
	}{
		Package:  "main", // This should be detected from the package
		Mappings: g.mappings,
	}

	return t.Execute(file, data)
}
